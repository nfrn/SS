from collections import OrderedDict
from Utils import *


class Vulnerability:
    VAR_OVERFLOW = "VAROVERFLOW"
    RBP_OVERFLOW = "RBPOVERFLOW"
    RET_OVERFLOW = "RETOVERFLOW"
    INVALID_ACCS = "INVALIDACCS"
    S_CORRUPTION = "SCORRUPTION"

    basic_vulns = [VAR_OVERFLOW , RBP_OVERFLOW , RET_OVERFLOW]
    adv_vulns = [INVALID_ACCS , S_CORRUPTION]

    def __init__(self,name, function, address, fnname, overflow_var, overflown_var = "", overflown_adr = "" ):
        if( (name not in self.basic_vulns) and (name not in self.adv_vulns)):
            raise Exception ("Unkown vulnerability")

        self.name = name
        self.function = function
        self.address = address
        self.fnname = fnname
        self.overflow_var = overflow_var

        self.overflown_var = overflown_var
        self.overflown_adr = overflown_adr
        self.op = ""

    def setOpCode(self,op):
        self.op = op

    def __str__(self):
        return self.name

    def toJSON( self ):
        output = {}
        output['vulnerability'] = self.name
        output['vuln_function'] = self.function
        output['address'] = self.address
        if self.op == "":
            output['fnname'] = self.fnname
            output['overflow_var'] = self.overflow_var
        else:
            output['op'] = self.op

        if(self.overflown_var != ""):
            output['overflown_var'] = self.overflown_var

        if (self.overflown_adr != ""):
            output['overflown_address'] = "rbp" + self.overflown_adr

        return output

def eval_direct_write(state, op_code, write_addr, char, curr_func ):
    inst_addr = state.store_reg["IP"]
    entry_addr, entry = state.get_entry_of_addr(write_addr)
    if(char in ("\0","0x0") and entry.type == TYPE_BUFFER):
        #change efective writen size because \0 terminates string at that point
        new_size = abs(int(write_addr,16) - int(entry_addr,16))
        state.sub_stack[entry_addr].write_size = new_size #only efective after cpy functions
    elif entry.type == TYPE_INT:
        vuln = Vulnerability(Vulnerability.INVALID_ACCS, curr_func, inst_addr,"", "", "",write_addr)
        vuln.setOpCode(op_code)
        state.add_vulnerability(vuln)
     #writing anything else than \0 to buffer is ok

def eval_function(state,fname,function):
    if fname == 'gets':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        state.sub_stack[globaldestination].set_write_size(-1, fname, function) # leads to check_write function below

    elif fname == 'fgets':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        size = state.store_reg['SI']
        state.sub_stack[globaldestination].set_write_size(int(size, 16), fname, function) # leads to check_write function below

    elif fname == 'strcpy':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        origin = trans_addr(state.store_reg['SI'][1:-1])
        if function == 'main':
            globalorigin = hex(int(state.current_function_pointer, 16) + int(origin, 16))
        else:
            globalorigin = hex(int(state.current_function_pointer, 16) - int(origin, 16))

        origin_size = state.sub_stack[globalorigin].write_size
        state.sub_stack[globaldestination].set_write_size(origin_size, fname, function) # leads to check_write function below

    elif fname == 'strncpy':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        dest_size = state.sub_stack[globaldestination].write_size

        origin = trans_addr(state.store_reg['SI'][1:-1])
        if function == 'main':
            globalorigin = hex(int(state.current_function_pointer, 16) + int(origin, 16))
        else:
            globalorigin = hex(int(state.current_function_pointer, 16) - int(origin, 16))

        origin_size = state.sub_stack[globalorigin].write_size
        ammount = int(trans_addr(state.store_reg['DX']), 16)
        #/0 not copied
        #size of dest var is equal to its size + next_buf size in stack
        if(ammount < origin_size-1):
            next_entry = state.next_item_in_stack(globaldestination)
            if(next_entry.type == TYPE_BUFFER):
                true_ammout = dest_size + next_entry.bytes
                state.sub_stack[globaldestination].write_size = true_ammout  #only effective later
            else:
                state.sub_stack[globaldestination].set_write_size(ammount, fname, function)
        else:
            state.sub_stack[globaldestination].set_write_size(ammount, fname, function)

    elif fname == 'strcat':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        already_writen = state.sub_stack[globaldestination].write_size
        orig = trans_addr(state.store_reg['SI'][1:-1])
        conca_size = state.sub_stack[orig].write_size
        ammount = already_writen + conca_size
        state.sub_stack[globaldestination].set_write_size(ammount, fname, function)

    elif fname == 'strncat':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        already_writen = state.sub_stack[destination].write_size
        orig = trans_addr(state.store_reg['SI'][1:-1])
        ammount = int(state.store_reg['DX'], 16)
        if (state.sub_stack[orig].write_size > ammount):
            conca_size = ammount
        else:
            conca_size = state.sub_stack[orig].write_size
        true_ammount = already_writen + conca_size
        state.sub_stack[destination].set_write_size(true_ammount, fname, function)

    elif fname == 'sprintf':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        # 6th argument should be in stack not in reg
        # first 2 args are where to put, and str_format
        total_size = args_size(state, 2)
        state.sub_stack[destination].set_write_size(total_size, fname, function)
    elif fname == 'snprintf':
        destination = trans_addr(state.store_reg['DI'][1:-1])
        # 6th argument should be in stack not in reg
        # first 3 args are where to put, number of bytes and str_format
        total_size = args_size(state, 3)
        state.sub_stack[destination].set_write_size(total_size, fname, function)

    elif fname == 'read':
        destination = trans_addr(state.store_reg['SI'][1:-1])
        globaldestination =  hex(int(state.current_function_pointer, 16) - abs(int(destination, 16)))
        amount = int(state.store_reg['DX'],16)
        state.sub_stack[globaldestination].set_write_size(amount, fname, function)

    elif fname == 'scanf' or fname == '__isoc99_scanf':
        destination = trans_addr(state.store_reg['SI'][1:-1])
        state.sub_stack[destination].set_write_size(-1, fname, function)

    elif fname == 'fscanf' or fname == '__isoc99_fscanf':
        destination = trans_addr(state.store_reg['DX'][1:-1])
        state.sub_stack[destination].set_write_size(-1, fname, function)
        # print("=====EVAL_FUNCTION===========")
        # print (fname)
        # print(state)
        # print("\n==\\\\\\EVAL_FUNCTION===========\n")

def args_size(state, low):
    '''gets allocated size of relevant vars from registers(used for passing args), starting from \'low\''''
    # arg_reg_order = ['RDI','RSI','RDX','RCX','R8','R9']
    total_size = 0
    for i in range(low, 6):
        # 0,1,2,3
        reg = arg_reg_order[i]
        if i <= 3:
            reg = reg[1:]
        if (state.store_reg[reg] == 0 or state.store_reg[reg] == '0x0'):
            break
        orig = trans_addr(state.store_reg[reg][1:-1])
        total_size += state.sub_stack[orig].write_size
    return total_size


#verifies values and adds vuln to stack vulnerabilities list
def check_write(entry, write_size, fnn, function_writing):
    function_instr_address = entry.stack.store_reg["IP"]
    ordered = entry.stack.ordered()
    if write_size==-1 : #unlimited
        unlimited_overflow(entry, ordered, fnn, function_writing, function_instr_address)
        return

    if(entry.bytes >= write_size ):
        #all good
        return

    diff = write_size - entry.bytes
    print("writing " + str(diff) + " more bytes than supposed to " + entry.name)
    var_end_addr = hex( int(entry.address,16) + entry.bytes)
    end_write = hex(int(var_end_addr,16) + diff)

    #calculate what exacly overwrites
    for addr, e in ordered.items():
        if int(addr,16) <= int(entry.address, 16):
            continue
        if int(addr,16) >= int(end_write,16):
            break
        address = function_instr_address
        ## overflow
        result = check_type_overflow(e,addr)
        if result != "UNKOWN TYPE":
            vuln_type, overflowndvar,overflown_address = result
            vulnerability = Vulnerability(vuln_type, function_writing, address,fnn, entry.name, overflowndvar,overflown_address)
            entry.stack.add_vulnerability(vulnerability)
    return 

def unlimited_overflow(entry, ordered, fnn , function_writing,function_instr_address):
    for addr, e in ordered.items():
        if int(entry.address,16) >= int(addr,16) :
            continue
        result = check_type_overflow(e, addr)
        if result != "UNKOWN TYPE":
            vuln_type, overflowndvar, overflown_address = result
            vulnerability = Vulnerability(vuln_type, function_writing, function_instr_address, fnn, entry.name, overflowndvar, overflown_address)
            entry.stack.add_vulnerability(vulnerability)

def check_type_overflow(overflown_entry,addr):
    if( overflown_entry.val == "NI"):
        return Vulnerability.INVALID_ACCS,"", addr
    elif( overflown_entry.val == "STK"):
        return Vulnerability.S_CORRUPTION,"", "+" + addr
    elif( overflown_entry.type in VAR_TYPES):
        return Vulnerability.VAR_OVERFLOW, overflown_entry.name, ""
    elif overflown_entry.type == "POINTER" and overflown_entry.name == "RET":
        return Vulnerability.RET_OVERFLOW, "", ""
    elif  overflown_entry.type == "POINTER" and overflown_entry.name =="RBP":
        return Vulnerability.RBP_OVERFLOW, "", ""
    elif (overflown_entry.name == "ARGS"):
        return Vulnerability.S_CORRUPTION, "", "+0x10"
    else:
        return "UNKOWN TYPE"

from collections import OrderedDict
from Utils import *


class Vulnerability:
    VAR_OVERFLOW = "VAROVERFLOW"
    RBP_OVERFLOW = "RBPOVERFLOW"
    RET_OVERFLOW = "RETOVERFLOW"
    INVALID_ACCS = "INVALIDACCS"
    S_CORRUPTION = "SCORRUPTION"

    basic_vulns = [VAR_OVERFLOW , RBP_OVERFLOW , RET_OVERFLOW]
    adv_vulns = [INVALID_ACCS , S_CORRUPTION]

    def __init__(self,name, function, address, fnname, overflow_var, overflown_var = "", overflown_adr = "" ):
        if( (name not in self.basic_vulns) and (name not in self.adv_vulns)):
            raise Exception ("Unkown vulnerability")

        self.name = name
        self.function = function
        self.address = address
        self.fnname = fnname
        self.overflow_var = overflow_var

        self.overflown_var = overflown_var
        self.overflown_adr = overflown_adr

    def setVar(self,var):
        self.var = var

    def setMainFunction(self,function):
        self.function = function

    def setAddress(self,address):
        self.address= address

    def setMalFunction(self,function):
        self.fnname = function

    def __str__(self):
        return self.name

    def toJSON( self ):
        output = {}
        output['vulnerability'] = self.name
        output['vuln_function'] = self.function
        output['address'] = self.address
        output['fnname'] = self.fnname
        output['overflow_var'] = self.overflow_var

        if(self.overflown_var != ""):
            output['overflown_var'] = self.overflown_var

        if (self.overflown_adr != ""):
            output['overflown_address'] = "rbp" + self.overflown_adr

        return output

def checkVulnerability(stack):
    print("cheking vulnerabilities")
    print(stack)
    vulnerabilities = []
    ordered_vals = stack.ordered()

    unlimited = False

    for add, stack_entry in ordered_vals.items():
        current_desc = stack_entry.descr.split(' ')
        if current_desc[0] == "Unlimited":
            unlimited = True
            calledFunctionPossible = current_desc[1]
            currentFunctionPossible = current_desc[2] 
            overflowvar = getVariableName(stack.program,add)

        elif current_desc[0] in ('INT','BUFFER') and unlimited:
            #This way we can detect multiple VAR_OVERFLOW
            overflowndvar = getVariableName(stack.program,add)
            address = getFunctionAdd(stack.program, calledFunctionPossible)   
            vulnerability = Vulnerability(Vulnerability.VAR_OVERFLOW, currentFunctionPossible, address, calledFunctionPossible, overflowvar,overflowndvar)
            vulnerabilities.append(vulnerability)

    if unlimited:
        vulnerability = Vulnerability(Vulnerability.RBP_OVERFLOW, currentFunctionPossible, address, calledFunctionPossible, overflowvar)
        vulnerabilities.append(vulnerability)

        vulnerability = Vulnerability(Vulnerability.RET_OVERFLOW, currentFunctionPossible, address, calledFunctionPossible, overflowvar)
        vulnerabilities.append(vulnerability)

    return vulnerabilities

def eval_function(stack,fname,function):
    destination = trans_addr(stack.store_reg['DI'][1:-1])
    
    if fname == 'gets':
        stack.sub_stack[destination].set_write_size(-1, fname, function) # leads to check_write function below

    elif fname == 'fgets':
        size = stack.store_reg['SI']
        stack.sub_stack[destination].set_write_size(int(size, 16), fname, function) # leads to check_write function below

    elif fname == 'strcpy':
        origin = trans_addr(stack.store_reg['SI'][1:-1])
        origin_size = stack.sub_stack[origin].write_size
        stack.sub_stack[destination].set_write_size(origin_size, fname, function) # leads to check_write function below

    elif fname == 'strncpy':
        origin = trans_addr(stack.store_reg['SI'][1:-1])
        ammount = int(trans_addr(stack.store_reg['DX']), 16)
        stack.sub_stack[destination].set_write_size(ammount, fname, function)

    elif fname == 'strcat':
        already_writen = stack.sub_stack[destination].write_size
        orig = trans_addr(stack.store_reg['SI'][1:-1])
        conca_size = stack.sub_stack[orig].write_size
        ammount = already_writen + conca_size 
        stack.sub_stack[destination].set_write_size(ammount, fname, function)

    elif fname == 'strncat':
        pass


#verifies values and adds vuln to stack vulnerabilities list
def check_write(entry, write_size, fnn, function_writing):
    print(entry.stack)
    ordered = entry.stack.ordered()
    if write_size==-1 : #unlimited
        unlimited_overflow(entry, ordered, fnn, function_writing)
        return

    if(entry.bytes >= write_size ):
        #all good
        return

    diff = write_size - entry.bytes
    print("writing " + str(diff) + " more bytes than supposed to " + entry.name)
    var_end_addr = hex( int(entry.address,16) + entry.bytes)
    end_write = hex(int(var_end_addr,16) + diff)
    #calculate what exacly overwrites
    for addr, e in ordered.items():
        if int(addr,16) <= int(entry.address, 16) :
            continue
        if int(addr,16) > int(end_write,16):
            break
        address = getFunctionAdd(entry.stack.program, fnn)
        ## overflow        
        vuln_type, overflowndvar,overflown_address= check_type_overflow(e,addr)
        vulnerability = Vulnerability(vuln_type, function_writing, address,fnn, entry.name, overflowndvar,overflown_address)
        entry.stack.add_vulnerability(vulnerability)
    return 

def unlimited_overflow(entry, ordered, fnn , function_writing):
    for addr, e in ordered.items():
        if addr >= entry.address:
            continue
        address = getFunctionAdd(entry.stack.program, fnn)
        vuln_type, overflowndvar, overflown_address  = check_type_overflow(e,addr)

        vulnerability = Vulnerability(vuln_type, function_writing, address, fnn, entry.name, overflowndvar,overflown_address)
        entry.stack.add_vulnerability(vulnerability)
        #EXTRA IF unlimited then RBP AND RET

    vulnerability = Vulnerability(Vulnerability.RBP_OVERFLOW, function_writing, address, fnn, entry.name,overflown_address)
    entry.stack.add_vulnerability(vulnerability)

    vulnerability = Vulnerability(Vulnerability.RET_OVERFLOW, function_writing, address, fnn, entry.name,overflown_address)
    entry.stack.add_vulnerability(vulnerability)

    vuln_type, overflowndvar, overflown_address = check_type_overflow(e, addr)
    vulnerability = Vulnerability(vuln_type, function_writing, address, fnn, entry.name, overflowndvar, overflown_address)
    entry.stack.add_vulnerability(vulnerability)

def check_type_overflow(overflown_entry,addr):
    if( overflown_entry.val == "NI"):
        return Vulnerability.INVALID_ACCS,"", addr
    elif( overflown_entry.val == "STK"):
        return Vulnerability.S_CORRUPTION,"", "+" + addr
    elif( overflown_entry.type in ("buffer", "int")):
        return Vulnerability.VAR_OVERFLOW, overflown_entry.name, ""
    elif overflown_entry.type == "POINTER" and overflown_entry.name == "RET":
        return Vulnerability.RET_OVERFLOW, "", ""
    elif  overflown_entry.type == "POINTER" and overflown_entry.name =="RBP":
        return Vulnerability.RBP_OVERFLOW, "", ""
    else:
        print("UNKOWN TYPE")

def getVariableName(program,add):
    for var in program.main.variables:
        if add == var.address:
            return var.name
    return 'ERROR'

def getFunctionAdd(program,function):

    for instr in program.main.instructions:
        if 'fnname' in instr.args.keys() and function == instr.args['fnname']:
            return instr.address
    return "ERROR"